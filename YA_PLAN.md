# Детальный Технический План Реализации YA Fork

Настоящий документ описывает детальный технический план по реализации и доработке OpenClaw YA Fork, ориентированного на упрощенный пользовательский интерфейс и онбординг в стиле "iPhone-style Product UI". План разбит на четыре фазы, с учетом текущей работы команды Codex над базовым product UI (`ya-product-ui-build`).

---

## Фаза 1 (Codex): Backend — RPC методы и логика

**Цель:** Реализовать или доработать ключевые RPC методы на бэкенде, необходимые для функциональности Product UI.

### Задача 1.1: Реализация `chat.greet` RPC

**Описание:** Полная реализация RPC метода `chat.greet`, который позволяет ассистенту отправить первое сообщение в чате без явного сообщения от пользователя. Это сообщение должно добавляться в транскрипт как сообщение ассистента и транслироваться как окончательное событие чата. Метод должен быть идемпотентным.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/chat.ts` (доработка stuba)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/chat.ts (или аналогичный)
    export type ChatGreetRequest = {
      sessionKey: string;
      reason?: "new_chat" | "reset" | "first_open";
      agentId?: string; // Если greet инициируется агентом
    };

    export type ChatGreetResponse = {
      ok: boolean;
      messageId?: string;
      message?: Record<string, any>; // Полное сообщение, которое было добавлено
      error?: string;
    };
    ```
*   **Зависимости от других задач:**
    *   Нет прямых внешних зависимостей в рамках этой фазы, но требуется для корректной работы UI "Новый чат" (Фаза 2).
*   **Acceptance Criteria:**
    *   Вызов `chat.greet` успешно добавляет сообщение ассистента в историю чата.
    *   Сообщение ассистента появляется в UI без ввода пользователем команды `/new`.
    *   Метод корректно обрабатывает параметр `reason`.
    *   Метод идемпотентен (повторные вызовы с тем же `sessionKey` в короткий период не приводят к дублированию приветствий, либо механизм идемпотентности работает корректно).

### Задача 1.2: Парсинг вложений (`attachments parsing`)

**Описание:** Доработка логики парсинга вложений для `chat.send`, чтобы обрабатывать различные типы файлов: изображения для Vision-моделей, текст/PDF для включения в промпт, и другие типы файлов для сохранения.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/chat-attachments.ts` (создание или доработка, если уже есть базовый парсинг)
    *   `src/lib/extract-file-content.ts` (доработка для PDF/text)
    *   `src/lib/store.ts` (для `saveMediaBuffer`)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/chat.ts (дополнение к ChatSendRequest)
    export type Attachment = {
      mimeType: string;
      fileName: string;
      content: string; // base64 encoded
      // Дополнительные поля по необходимости
    };

    export type ChatSendRequest = {
      // ... другие поля
      attachments?: Attachment[];
    };
    ```
*   **Зависимости от других задач:**
    *   `chat.send` RPC (существующий) для передачи данных о вложениях.
    *   Требуется для UI "Вложения" (Фаза 2).
*   **Acceptance Criteria:**
    *   Изображения (`image/*`, до 10MB) успешно передаются в модель как `images[]`.
    *   Текстовые файлы (`text/*`, `application/json`, `text/csv`, `text/html`, до 5MB) извлекаются и добавляются в промпт.
    *   PDF файлы извлекаются (текст в промпт, изображения в `images[]`).
    *   Прочие типы файлов (docx/pptx/mp4) сохраняются через `saveMediaBuffer`, и в транскрипт добавляется уведомление о сохранении файла.
    *   Соблюдаются лимиты на размер файлов; ошибки лимитов отображаются пользователю.

### Задача 1.3: Реализация `agents.create` RPC

**Описание:** Создание RPC метода `agents.create` для создания новых проектов (агентов) из UI.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/agents.ts` (создание, если нет, или доработка)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/agents.ts (новый файл)
    export type AgentCreateRequest = {
      id: string; // Уникальный ID агента (например, из displayName)
      displayName: string;
      description?: string;
      workspace?: string; // Путь к рабочей директории агента
      model?: string; // Дефолтная модель для агента
      persona?: string; // Путь к файлу persona (для agents.files.set)
    };

    export type AgentCreateResponse = {
      ok: boolean;
      agentId?: string;
      error?: string;
    };
    ```
*   **Зависимости от других задач:**
    *   Требуется для UI "Создать проект" (Фаза 2).
*   **Acceptance Criteria:**
    *   Вызов `agents.create` успешно создает нового агента с указанными параметрами.
    *   Новый агент отображается в списке проектов UI.
    *   Возможность указать `workspace` и `persona` при создании.

### Задача 1.4: Доработка `sessions.list` RPC

**Описание:** Доработка существующего `sessions.list` RPC метода для поддержки фильтрации по `agentId`, включения производных заголовков (`derivedTitles`) и последнего сообщения для отображения в Product UI.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/sessions.ts` (доработка)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/sessions.ts (дополнение к SessionsListRequest/Result)
    export type SessionsListRequest = {
      agentId?: string; // Фильтрация по ID агента
      includeDerivedTitles?: boolean; // Включить автоматически сгенерированные заголовки
      includeLastMessage?: boolean; // Включить последнее сообщение для предпросмотра
      // ... существующие поля
    };

    export type SessionsListItem = {
      key: string;
      label?: string;
      derivedTitle?: string; // Автоматически сгенерированный заголовок
      lastMessage?: {
        text: string;
        timestamp: number;
        // ... другие поля сообщения
      };
      // ... существующие поля сессии
    };

    export type SessionsListResult = {
      sessions: SessionsListItem[];
    };
    ```
*   **Зависимости от других задач:**
    *   Используется для отображения списка чатов в Sidebar Product UI (Фаза 2).
*   **Acceptance Criteria:**
    *   `sessions.list` возвращает список сессий, отфильтрованный по `agentId`.
    *   Список сессий включает `derivedTitle` (если доступно).
    *   Список сессий включает `lastMessage` (для отображения в UI).
    *   Производительность метода остается приемлемой для большого количества сессий (при необходимости рассмотреть пагинацию).

---

## Фаза 2 (Codex): Frontend — Полный Product UI

**Цель:** Завершить разработку Product UI (`app-render-product.ts`), интегрировав все необходимые элементы управления и экраны.

### Задача 2.1: Завершение `app-render-product.ts` и 3-колонный Layout

**Описание:** Доработка `app-render-product.ts` до полного соответствия макету Product UI с 3-колонным расположением (Icon rail, Sidebar, Main content). Интеграция и отображение всех навигационных элементов и основных экранов.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/app-render-product.ts` (основная доработка)
    *   `ui/src/styles/layout.css` (проверка и финализация стилей для layout)
*   **Интерфейс TypeScript:**
    *   `ui/src/ui/app-view-state.ts` (добавление состояний для управления активными панелями и элементами UI)
*   **Зависимости от других задач:**
    *   Задача 2.2, 2.3, 2.4 (кнопки, Telegram экран, Reset) — будут интегрированы в этот layout.
    *   Фаза 1 — Backend RPC для отображения данных.
*   **Acceptance Criteria:**
    *   UI корректно отображает 3-колонный layout: Icon rail (64px), Sidebar (280px), Main content (1fr).
    *   Навигация между панелями (Чат, Проекты, Telegram) работает корректно.
    *   Активная панель отображается в Main content.
    *   UI соответствует концепции "iPhone-style Product UI".

### Задача 2.2: Интеграция кнопок управления чатом

**Описание:** Добавление кнопок "Новый чат", "Сбросить чат", "Вложения", "Стоп" в интерфейс чата Product UI и привязка их к соответствующим backend RPC методам.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/app-render-product.ts`
    *   `ui/src/ui/app-view-state.ts` (для управления состоянием кнопок: loading, disabled)
*   **Интерфейс TypeScript:**
    *   Не требуется новых, используются существующие для RPC.
*   **Зависимости от других задач:**
    *   Задача 1.1 (`chat.greet` RPC) для "Новый чат" и "Сбросить чат".
    *   Задача 1.2 (attachments parsing) для "Вложения".
    *   Существующий `chat.abort` RPC для "Стоп".
*   **Acceptance Criteria:**
    *   Кнопки "Новый чат", "Сбросить чат", "Вложения", "Стоп" всегда видны в чате.
    *   Нажатие "Новый чат" создает новую subagent сессию и вызывает `chat.greet`.
    *   Нажатие "Сбросить чат" вызывает `sessions.reset()` и `chat.greet`.
    *   Кнопка "Вложения" открывает file picker, поддерживает drag&drop и paste.
    *   Кнопка "Стоп" вызывает `chat.abort()`.
    *   Slash-команды скрыты из UX.

### Задача 2.3: Реализация экрана Telegram

**Описание:** Создание и интеграция UI для подключения Telegram, включая поля для Bot Token и User ID, отображение статуса подключения и логики для сохранения конфигурации.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/app-render-product.ts` (добавление секции рендера Telegram)
    *   `ui/src/ui/app-view-state.ts` (добавление состояний для Telegram: token, userId, loading, error, success)
    *   `src/gateway/server-methods/channels.ts` (для RPC `channels.telegram.save`)
    *   `src/gateway/protocol/schema/channels.ts` (для типов `ChannelTelegramConfigSchema`)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/channels.ts
    export type ChannelTelegramSaveRequest = {
      token: string;
      allowFrom: (string | number)[]; // Массив user ID, которым разрешено взаимодействовать
    };

    export type ChannelTelegramSaveResponse = {
      ok: boolean;
      probe?: Record<string, any>; // Информация о результате подключения
      error?: string;
    };
    ```
*   **Зависимости от других задач:**
    *   Новый RPC `channels.telegram.save` на бэкенде (будет добавлен в рамках этой задачи на бэкенде, но относится к фронтенд-фазе по инициатору).
*   **Acceptance Criteria:**
    *   Доступен экран Telegram через Icon rail.
    *   На экране отображаются поля ввода "Bot Token" и "Твой user id".
    *   Кнопка "Применить" отправляет данные на бэкенд через `channels.telegram.save` RPC.
    *   Отображается статус подключения Telegram (подключено/не подключено/ошибка).
    *   Сообщения об успехе/ошибке подключения отображаются пользователю.

### Задача 2.4: Реализация кнопки "Сбросить всё" в Dev Drawer

**Описание:** Добавление кнопки "Сбросить всё" в Dev Drawer (доступном в Product UI) с подтверждением действия, очисткой всех настроек и перезапуском Gateway. После сброса UI должен предлагать онбординг.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/app-render-product.ts` (логика кнопки и вызов RPC)
    *   `ui/src/ui/app-view-state.ts` (состояние для Dev Drawer, модального окна подтверждения)
    *   `src/gateway/server-methods/config.ts` (для RPC `config.reset`)
*   **Интерфейс TypeScript:**
    ```typescript
    // src/gateway/protocol/schema/config.ts
    export type ConfigResetRequest = {
      scope: "full"; // Возможно, другие scope в будущем
    };
    export type ConfigResetResponse = {
      ok: boolean;
      error?: string;
    };
    ```
*   **Зависимости от других задач:**
    *   Существующая логика онбординга (для предложения онбординга после сброса).
*   **Acceptance Criteria:**
    *   В Dev Drawer есть кнопка "Сбросить всё".
    *   При нажатии на кнопку появляется модальное окно подтверждения.
    *   После подтверждения Gateway перезапускается с чистым состоянием.
    *   Product UI после перезапуска предлагает онбординг: "Ввести Eliza API key", "Создать проект", "Подключить Telegram".

---

## Фаза 3 (Gemini): UX-доработки — Полировка интерфейса

**Цель:** Улучшение пользовательского опыта через добавление анимаций, адаптацию для мобильных устройств, общую полировку, улучшение доступности и внедрение темной темы.

### Задача 3.1: Анимации и визуальная полировка

**Описание:** Добавление плавных анимаций (fade-in, slide transitions) для переходов между состояниями UI, открытия/закрытия панелей, модальных окон. Общая визуальная полировка элементов Product UI.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/styles/*.css` (добавление CSS-переходов и анимаций)
    *   `ui/src/ui/**/*.ts` (управление классами CSS для анимаций при рендеринге)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Завершенный Product UI (Фаза 2).
*   **Acceptance Criteria:**
    *   Переходы между панелями и состояниями UI выглядят плавно.
    *   Модальные окна появляются и исчезают с анимацией.
    *   Общий вид UI более современный и отполированный.
    *   Устранены мелкие визуальные "косяки" и несоответствия.

### Задача 3.2: Мобильная адаптивность (уточнение)

**Описание:** Уточнение и доработка мобильной адаптивности Product UI, особенно для онбординга, чтобы обеспечить оптимальное отображение и взаимодействие на маленьких экранах.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/styles/layout.mobile.css` (доработка media queries и стилей)
    *   `ui/src/styles/product.css` (адаптация компонентов)
    *   `ui/src/ui/**/*.ts` (возможная адаптация логики рендера для мобильных)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Завершенный Product UI (Фаза 2).
*   **Acceptance Criteria:**
    *   Product UI корректно отображается и полностью функционален на экранах с шириной до 768px.
    *   Онбординг flow удобен и понятен на мобильных устройствах.
    *   Элементы управления чатом и навигация легко доступны на мобильных.
    *   Нет горизонтальной прокрутки, текст читаем, интерактивные элементы имеют достаточный размер.

### Задача 3.3: Доступность (Accessibility)

**Описание:** Внедрение стандартов доступности (ARIA labels, управление фокусом, поддержка скринридеров) для всех интерактивных элементов и ключевых частей Product UI.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/**/*.ts` (добавление ARIA-атрибутов, управление focus'ом)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Завершенный Product UI (Фаза 2).
*   **Acceptance Criteria:**
    *   Все интерактивные элементы имеют корректные ARIA-метки.
    *   Tab-навигация по всему UI работает логично и предсказуемо.
    *   Скринридеры корректно озвучивают элементы и состояние UI.
    *   Обеспечен достаточный цветовой контраст.

### Задача 3.4: Темная тема (Dark Mode)

**Описание:** Завершение адаптации всех компонентов Product UI под темную тему, используя существующие CSS-переменные.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/styles/*.css` (проверка и доработка стилей для `:root[data-theme='dark']`)
    *   `ui/src/ui/**/*.ts` (управление переключением темы)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Завершенный Product UI (Фаза 2).
*   **Acceptance Criteria:**
    *   Product UI полностью поддерживает темную тему.
    *   Все элементы корректно отображаются в темной теме, без артефактов и "выбивающихся" цветов.
    *   Переключение темы (если есть) работает без проблем.

---

## Фаза 4 (Opus): Тесты + Финальная проверка

**Цель:** Написание всех необходимых тестов (unit, UI render, e2e) для подтверждения работоспособности реализованных функций и финальная проверка всего продукта.

### Задача 4.1: Unit тесты для `chat.greet`

**Описание:** Написание unit-тестов для RPC метода `chat.greet`, проверяющих его функциональность, идемпотентность и корректность добавления сообщений.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/chat.test.ts` (создание или доработка)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Задача 1.1 (реализация `chat.greet`).
*   **Acceptance Criteria:**
    *   Тесты покрывают основные сценарии вызова `chat.greet`.
    *   Проверяется добавление сообщения в историю.
    *   Проверяется корректность трансляции события.
    *   Проверяется обработка идемпотентности.
    *   Все тесты проходят успешно.

### Задача 4.2: Unit тесты для парсинга вложений

**Описание:** Написание unit-тестов для логики парсинга вложений, проверяющих обработку различных типов файлов, лимитов и формирование данных для модели/хранилища.

*   **Конкретный файл для изменения/создания:**
    *   `src/gateway/server-methods/chat-attachments.test.ts` (создание)
    *   `src/lib/extract-file-content.test.ts` (доработка или создание)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Задача 1.2 (attachments parsing).
*   **Acceptance Criteria:**
    *   Тесты покрывают парсинг изображений, PDF, текстовых и прочих файлов.
    *   Проверяется соблюдение лимитов на размер файлов.
    *   Проверяется корректное формирование `images[]` для модели.
    *   Проверяется извлечение текста из поддерживаемых документов.
    *   Все тесты проходят успешно.

### Задача 4.3: UI Render тесты для панели кнопок и основных компонентов Product UI

**Описание:** Создание UI render тестов для критически важных компонентов Product UI, в частности для панели кнопок чата и основных навигационных элементов.

*   **Конкретный файл для изменения/создания:**
    *   `ui/src/ui/app-render-product.test.ts` (создание)
    *   `ui/src/ui/components/*.test.ts` (при необходимости, для изолированных компонентов)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Фаза 2 (полный Product UI).
*   **Acceptance Criteria:**
    *   Тесты проверяют корректное отображение кнопок "Новый чат", "Сбросить чат", "Вложения", "Стоп".
    *   Проверяется корректное отображение Icon rail и Sidebar.
    *   Проверяется, что скрытые элементы (например, slash-команды) не рендерятся.
    *   Все тесты проходят успешно.

### Задача 4.4: E2E сценарий "чистый старт до Telegram setup"

**Описание:** Разработка сквозного E2E теста, который имитирует полный пользовательский путь: чистый старт, прохождение онбординга Eliza, создание проекта, начало нового чата с ассистентом, использование вложений, сброс чата и настройка Telegram.

*   **Конкретный файл для изменения/создания:**
    *   `e2e/product-onboarding-flow.test.ts` (создание)
*   **Интерфейс TypeScript:** Не требуется.
*   **Зависимости от других задач:**
    *   Все задачи Фазы 1, 2 и 3.
*   **Acceptance Criteria:**
    *   E2E тест успешно проходит по сценарию:
        1.  Чистый запуск Gateway.
        2.  Доступ к Product UI.
        3.  Прохождение онбординга Eliza (ввод API ключа).
        4.  Создание нового проекта через UI.
        5.  Начало нового чата в созданном проекте, получение первого сообщения от ассистента (`chat.greet`).
        6.  Успешная отправка сообщения с вложениями (например, изображением).
        7.  Сброс текущего чата.
        8.  Успешная настройка Telegram через UI (ввод токена и user ID).
    *   Все шаги теста выполняются без ошибок.
    *   Тест подтверждает интеграцию всех ключевых функций.
