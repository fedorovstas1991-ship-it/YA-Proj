import { describe, it, expect, beforeAll } from "vitest";
import { execSync } from "node:child_process";
import path from "node:path";
import fs from "node:fs";

describe("Autonomous setup", () => {
  const projectRoot = path.join(__dirname, "../..");
  
  beforeAll(() => {
    // Ensure project is built
    if (!fs.existsSync(path.join(projectRoot, "dist/entry.js"))) {
      throw new Error("Project not built. Run: pnpm build");
    }
  });

  it("loads extensions from local directory", () => {
    const extensionsPath = path.join(projectRoot, "extensions");
    expect(fs.existsSync(extensionsPath)).toBe(true);
    
    const memoryCorePath = path.join(extensionsPath, "memory-core");
    expect(fs.existsSync(memoryCorePath)).toBe(true);
    
    const configPath = path.join(memoryCorePath, "config.ts");
    expect(fs.existsSync(configPath)).toBe(true);
  });

  it("uses isolated state directory", () => {
    const stateDir = path.join(process.env.HOME!, ".YA-yagent");
    // State dir will be created on first run
    // Just verify the path is correct
    expect(stateDir).toContain(".YA-yagent");
    expect(stateDir).not.toContain(".openclaw");
  });

  it("loads skills from bundled directory", () => {
    const skillsPath = path.join(projectRoot, "skills");
    
    // Check if skills exist
    if (fs.existsSync(skillsPath)) {
      const skills = fs.readdirSync(skillsPath).filter(
        (name) => !name.startsWith('.')
      );
      expect(skills.length).toBeGreaterThan(0);
      expect(skills).toContain("brainstorming");
      expect(skills).toContain("systematic-debugging");
      expect(skills).toContain("writing-plans");
      expect(skills).toContain("executing-plans");
    } else {
      console.warn("⚠️ Skills not synced yet. Run: ./scripts/sync-skills.sh");
    }
  });

  it("has correct entry points", () => {
    const entryMjs = path.join(projectRoot, "openclaw.mjs");
    const runNodeMjs = path.join(projectRoot, "scripts/run-node.mjs");
    const distEntry = path.join(projectRoot, "dist/entry.js");
    
    expect(fs.existsSync(entryMjs)).toBe(true);
    expect(fs.existsSync(runNodeMjs)).toBe(true);
    expect(fs.existsSync(distEntry)).toBe(true);
  });

  it("has control UI built", () => {
    const controlUiPath = path.join(projectRoot, "dist/control-ui");
    expect(fs.existsSync(controlUiPath)).toBe(true);
    
    const indexHtml = path.join(controlUiPath, "index.html");
    expect(fs.existsSync(indexHtml)).toBe(true);
  });

  it("yagent-onboard-ui.command uses local skills", () => {
    const scriptPath = path.join(projectRoot, "yagent-onboard-ui.command");
    expect(fs.existsSync(scriptPath)).toBe(true);
    
    const content = fs.readFileSync(scriptPath, "utf-8");
    // Check that skills config uses $ROOT_DIR/skills
    expect(content).toContain('$ROOT_DIR/skills');
    expect(content).not.toContain('Projects/superpowers/skills');
  });

  it("yagent-onboard-ui.command always performs full reset", () => {
    const scriptPath = path.join(projectRoot, "yagent-onboard-ui.command");
    expect(fs.existsSync(scriptPath)).toBe(true);

    const content = fs.readFileSync(scriptPath, "utf-8");
    expect(content).not.toContain("OPENCLAW_HARD_RESET");
    expect(content).not.toContain("HAS_TELEGRAM");
    expect(content).not.toContain("keeping existing config");
    expect(content).toContain('echo "Fresh start: state dir reset."');
  });

  it("yagent-onboard-ui.command clears keychain secrets during reset", () => {
    const scriptPath = path.join(projectRoot, "yagent-onboard-ui.command");
    expect(fs.existsSync(scriptPath)).toBe(true);

    const content = fs.readFileSync(scriptPath, "utf-8");
    expect(content).toContain("YAgent Secrets");
    expect(content).toContain("security delete-generic-password");
  });

  it("control UI reset opens main session instead of autogenerated subagent", () => {
    const settingsPath = path.join(projectRoot, "ui/src/ui/app-settings.ts");
    expect(fs.existsSync(settingsPath)).toBe(true);

    const content = fs.readFileSync(settingsPath, "utf-8");
    expect(content).toContain('const mainSessionKey = "agent:main:main"');
    expect(content).not.toContain("agent:main:subagent:${crypto.randomUUID()}");
  });

  it("has all required scripts", () => {
    const scripts = [
      "scripts/sync-skills.sh",
      "scripts/build-autonomous.sh",
      "scripts/verify-isolation.sh",
      "scripts/test-autonomous-setup.sh"
    ];
    
    for (const script of scripts) {
      const scriptPath = path.join(projectRoot, script);
      expect(fs.existsSync(scriptPath)).toBe(true);
      
      // Check if executable
      const stats = fs.statSync(scriptPath);
      const isExecutable = (stats.mode & 0o111) !== 0;
      expect(isExecutable).toBe(true);
    }
  });

  it("has updated documentation", () => {
    const docsPath = path.join(projectRoot, "YANDEXAGETN.md");
    expect(fs.existsSync(docsPath)).toBe(true);
    
    const content = fs.readFileSync(docsPath, "utf-8");
    expect(content).toContain("Локальная сборка и запуск");
    expect(content).toContain("build-autonomous.sh");
    expect(content).toContain("verify-isolation.sh");
  });

  it("package.json has test:autonomous script", () => {
    const packagePath = path.join(projectRoot, "package.json");
    expect(fs.existsSync(packagePath)).toBe(true);
    
    const pkg = JSON.parse(fs.readFileSync(packagePath, "utf-8"));
    expect(pkg.scripts["test:autonomous"]).toBeDefined();
    expect(pkg.scripts["test:autonomous"]).toContain("test-autonomous-setup.sh");
  });
});
